<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Grade Calculator</title>
  <style>
    :root {
      --gap: 16px;
      --radius: 10px;
      --muted: #666;
      --warn: #c77;
      --chip: #2a4d8f;
    }
    * {
      box-sizing: border-box;
    }
    body {
      font-family: system-ui, Arial, sans-serif;
      margin: 24px;
      line-height: 1.4;
    }
    h1 {
      margin: 0 0 12px;
    }
    .grid {
      display: grid;
      gap: var(--gap);
      grid-template-columns: repeat(2, minmax(280px, 1fr));
    }
    .card {
      border: 1px solid #ddd;
      border-radius: var(--radius);
      padding: 14px;
      background: #fff;
    }
    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px 12px;
      align-items: center;
    }
    .row label {
      white-space: nowrap;
    }
    input[type="number"],
    input[type="text"],
    select {
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 8px;
      width: 120px;
    }
    input[type="text"] {
      width: 180px;
    }
    button {
      padding: 8px 12px;
      border: 1px solid #ccc;
      border-radius: 999px;
      background: #fafafa;
      cursor: pointer;
    }
    .primary {
      background: #0a8;
      color: #fff;
      border-color: #0a8;
    }
    .item-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 6px 0;
    }
    .remove {
      color: #b00;
      font-weight: 700;
      cursor: pointer;
      border: none;
      background: transparent;
    }
    .pill {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      background: #eef4ff;
      color: #1f3a75;
      font-weight: 600;
    }
    .avg {
      font-weight: 700;
      color: var(--chip);
      margin-top: 6px;
    }
    .green {
      background: #d9ffe3 !important;
    }
    .muted {
      color: var(--muted);
    }
    .warn {
      color: var(--warn);
      font-weight: 600;
    }
    .result {
      white-space: pre-line;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    }
    .hr {
      height: 1px;
      background: #eee;
      margin: 12px 0;
    }
  </style>
</head>
<body>
  <h1>Grade Calculator</h1>

  <!-- Mode selection -->
  <section class="card" style="margin-bottom: 16px;">
    <div class="row">
      <b>Mode:</b>
      <label>
        <input type="radio" name="mode" id="mode-prelim" value="prelim" /> Prelims
      </label>
      <label>
        <input type="radio" name="mode" id="mode-term" value="term" /> Midterms/Finals
      </label>
    </div>
    <div class="row" id="prev-grade-row" style="margin-top: 8px; display: none;">
      <label>
        Previous Term Average %
        <input type="number" id="prev-grade" placeholder="e.g. 86" min="0" max="100" />
      </label>
    </div>
  </section>

  <div class="grid">
    <!-- Class Standing card -->
    <section class="card">
      <div class="row" style="justify-content: space-between;">
        <h2 style="margin: 0;">Class Standing <span class="pill" id="pill-cs">50%</span></h2>
        <span id="weight-warning" class="muted"></span>
      </div>
      <div id="categories"></div>
      <div class="row" style="margin-top: 8px;">
        <button id="add-category">Add Category</button>
      </div>
    </section>

    <!-- Exam card -->
    <section class="card">
      <h2 style="margin: 0;">Exam <span class="pill" id="pill-exam">50%</span></h2>
      <div class="row" style="margin-top: 8px;">
        <label>
          Score <input type="number" id="exam-score" placeholder="e.g. 45" />
        </label>
        <label>/ <input type="number" id="exam-total" placeholder="e.g. 50" /></label>
        <span id="exam-avg" class="avg">Exam Average: 0%</span>
      </div>
      <div class="hr"></div>
      <div class="row">
        <label>
          Target Equivalence
          <select id="target-eq">
            <option value="3.00" selected>3.00</option>
            <option value="2.75">2.75</option>
            <option value="2.50">2.50</option>
            <option value="2.25">2.25</option>
            <option value="2.00">2.00</option>
            <option value="1.75">1.75</option>
            <option value="1.50">1.50</option>
            <option value="1.25">1.25</option>
            <option value="1.00">1.00</option>
          </select>
        </label>
        <button id="compute" class="primary">Compute Minimum</button>
      </div>
      <div class="hr"></div>
      <div class="row">
        <span>Final Weight Mix:</span>
        <span class="pill" id="mix-cs">CS 50%</span>
        <span class="pill" id="mix-exam">Exam 50%</span>
        <span class="pill" id="mix-prev" style="display: none;">Prev 33%</span>
      </div>
      <div class="hr"></div>
      <div id="summary" class="result"></div>
    </section>
  </div>

  <div class="row" style="margin-top: 14px;">
    <button id="reset" class="ghost">Reset Scores</button>
  </div>

  <script>
    // ---------- Utility functions ----------
    const $ = (s) => document.querySelector(s);
    const $$ = (s) => Array.from(document.querySelectorAll(s));
    const clamp = (v, a, b) => Math.min(Math.max(v, a), b);
    const toNum = (v) => (Number.isFinite(parseFloat(v)) ? parseFloat(v) : 0);
    const ceilInt = (v) => Math.ceil(v);

    // Equivalence map: grade to percent threshold
    const EQUIV_MAP = {
      "1.00": 99,
      "1.25": 96,
      "1.50": 93,
      "1.75": 90,
      "2.00": 87,
      "2.25": 84,
      "2.50": 81,
      "2.75": 78,
      "3.00": 75,
    };
    const eqToPercent = (eq) => EQUIV_MAP[eq] ?? 75;
    function percentToEquivalence(p) {
      if (p >= 99) return "1.00 (Excellent)";
      if (p >= 96) return "1.25 (Superior)";
      if (p >= 93) return "1.50 (Meritorious)";
      if (p >= 90) return "1.75 (Very Good)";
      if (p >= 87) return "2.00 (Good)";
      if (p >= 84) return "2.25 (Very Satisfactory)";
      if (p >= 81) return "2.50 (Satisfactory)";
      if (p >= 78) return "2.75 (Fair)";
      if (p >= 75) return "3.00 (Passing)";
      return "5.00 (Failed)";
    }
    // Base-50 mapping: percent = 50 + 50 * (score/total)
    const map50 = (score, total) =>
      total > 0 ? clamp(50 + 50 * (score / total), 50, 100) : 0;

    // ---------- Template builders ----------
    function categoryTemplate(name = "Category", weight = 50) {
      const div = document.createElement("div");
      div.className = "card";
      div.style.margin = "10px 0";
      div.innerHTML = `
        <div class="row" style="justify-content: space-between;">
          <div class="row">
            <label>Name <input type="text" class="cat-name" value="${name}" /></label>
            <label>Weight % <input type="number" class="cat-weight" value="${weight}" /></label>
            <button class="remove" title="Remove category">&times;</button>
            <span class="avg">Category Average: 0%</span>
          </div>
        </div>
        <div class="items"></div>
        <div class="row"><button class="add-item">Add Item</button></div>
      `;
      div.querySelector(".items").appendChild(itemTemplate());
      return div;
    }
    function itemTemplate() {
      const r = document.createElement("div");
      r.className = "item-row";
      r.innerHTML = `
        <label>Score <input type="number" class="score" placeholder="e.g. 18" /></label>
        <label>/ <input type="number" class="total" placeholder="e.g. 20" /></label>
        <button class="remove" title="Remove item">&times;</button>
      `;
      return r;
    }

    // ---------- Averages ----------
    function categoryAverage(cat) {
      const rows = Array.from(cat.querySelectorAll(".item-row"));
      let sumScore = 0;
      let sumTotal = 0;
      rows.forEach((r) => {
        const sc = toNum(r.querySelector(".score").value);
        const tt = toNum(r.querySelector(".total").value);
        sumScore += sc;
        sumTotal += tt;
      });
      return map50(sumScore, sumTotal);
    }
    function classStandingAverage() {
      const cats = $$("#categories > .card");
      let wsum = 0;
      let acc = 0;
      cats.forEach((cat) => {
        const w = toNum(cat.querySelector(".cat-weight").value);
        const avg = categoryAverage(cat);
        if (w > 0) {
          acc += avg * w;
          wsum += w;
        }
      });
      return wsum > 0 ? acc / wsum : 0;
    }
    function examAverage() {
      const s = toNum($("#exam-score").value);
      const t = toNum($("#exam-total").value);
      return map50(s, t);
    }
    function getMode() {
      return $("#mode-term").checked ? "term" : "prelim";
    }
    function getWeights() {
      return getMode() === "term"
        ? { wCS: 1 / 3, wExam: 1 / 3, wPrev: 1 / 3 }
        : { wCS: 0.5, wExam: 0.5, wPrev: 0 };
    }
    function finalPercent(cs, ex, prev) {
      const { wCS, wExam, wPrev } = getWeights();
      return wCS * cs + wExam * ex + wPrev * prev;
    }

    // ---------- UI updates ----------
    function updateModeUI() {
      const mode = getMode();
      const prevRow = $("#prev-grade-row");
      const pillCS = $("#pill-cs");
      const pillEx = $("#pill-exam");
      const mixCS = $("#mix-cs");
      const mixEx = $("#mix-exam");
      const mixPrev = $("#mix-prev");
      if (mode === "term") {
        prevRow.style.display = "flex";
        if (pillCS) pillCS.textContent = "33%";
        if (pillEx) pillEx.textContent = "33%";
        if (mixCS) mixCS.textContent = "CS 33%";
        if (mixEx) mixEx.textContent = "Exam 33%";
        if (mixPrev) mixPrev.style.display = "inline-block";
      } else {
        prevRow.style.display = "none";
        if (pillCS) pillCS.textContent = "50%";
        if (pillEx) pillEx.textContent = "50%";
        if (mixCS) mixCS.textContent = "CS 50%";
        if (mixEx) mixEx.textContent = "Exam 50%";
        if (mixPrev) mixPrev.style.display = "none";
      }
    }
    function recalcAll() {
      // update category averages
      $$("#categories > .card").forEach((cat) => {
        const avg = categoryAverage(cat);
        cat.querySelector(".avg").textContent = `Category Average: ${avg.toFixed(2)}%`;
      });
      // weights health
      const totalW = $$("#categories > .card").reduce(
        (acc, cat) => acc + toNum(cat.querySelector(".cat-weight").value),
        0
      );
      const warn = $("#weight-warning");
      if (warn) {
        if (totalW === 100) {
          warn.textContent = "Weights sum to 100% ✓";
          warn.className = "muted";
        } else {
          warn.textContent = `Weights sum to ${totalW.toFixed(2)}%`;
          warn.className = "warn";
        }
      }
      // exam avg
      const ex = examAverage();
      $("#exam-avg").textContent = `Exam Average: ${ex.toFixed(2)}%`;
      // final grade & equivalence
      const cs = classStandingAverage();
      const prev = toNum($("#prev-grade").value);
      const fin = finalPercent(cs, ex, prev);
      $("#summary").textContent =
        `Class Standing Average:   ${cs.toFixed(2)}%\n` +
        `Exam Average:             ${ex.toFixed(2)}%\n` +
        (getMode() === "term"
          ? `Previous Term Average:     ${isNaN(prev) ? 0 : prev.toFixed(2)}%\n`
          : "") +
        `✅ Final Grade:            ${fin.toFixed(2)}%\n` +
        `Equivalence:               ${percentToEquivalence(fin)}`;
    }

    // ---------- Validation ----------
    function validateBeforeCompute() {
      // exam total must be >0
      const exTot = $("#exam-total").value.trim();
      if (exTot === "" || toNum(exTot) <= 0) {
        alert("Please enter a valid Exam total.");
        return false;
      }
      // previous term required in term mode
      if (getMode() === "term" && $("#prev-grade").value.trim() === "") {
        alert("Please enter the Previous Term Average.");
        return false;
      }
      // each item total must be >0
      const totals = $$("#categories .item-row .total");
      for (const t of totals) {
        if (t.value.trim() === "" || toNum(t.value) <= 0) {
          alert("Please enter a valid Total for every item.");
          return false;
        }
      }
      return true;
    }

    // ---------- Compute minimum (CS-first) ----------
    function computeMinimum() {
      if (!validateBeforeCompute()) return;
      const target = eqToPercent($("#target-eq").value);
      const exTotal = toNum($("#exam-total").value);
      const { wCS, wExam, wPrev } = getWeights();
      const prev = toNum($("#prev-grade").value) || 0;
      const examInput = $("#exam-score");
      // Determine if exam is locked by user (white box)
      const examUserLocked =
        examInput.value.trim() !== "" && !examInput.classList.contains("green");
      let examPoints = clamp(Math.trunc(toNum(examInput.value) || 0), 0, exTotal);
      let examPerc = map50(examPoints, exTotal);

      // Build category buckets: each with locked points and editable totals
      const cats = $$("#categories > .card");
      let wsum = 0;
      const buckets = [];
      cats.forEach((cat) => {
        const weight = toNum(cat.querySelector(".cat-weight").value);
        if (weight <= 0) return;
        let lockedS = 0;
        let lockedT = 0;
        let editableTotal = 0;
        const editRows = [];
        Array.from(cat.querySelectorAll(".item-row")).forEach((r) => {
          const tot = toNum(r.querySelector(".total").value);
          if (tot <= 0) return;
          const sIn = r.querySelector(".score");
          const userLocked =
            sIn.value.trim() !== "" && !sIn.classList.contains("green");
          if (userLocked) {
            lockedS += toNum(sIn.value);
            lockedT += tot;
          } else {
            editableTotal += tot;
            editRows.push({ row: r, total: tot });
          }
        });
        const T = lockedT + editableTotal;
        if (T <= 0) return;
        const minP = map50(lockedS, T); // CS percent at minimal (editable = 0)
        const maxP = map50(lockedS + editableTotal, T); // CS percent at max (editable = E)
        const cap = Math.max(0, maxP - minP);
        const gainPerPoint =
          (50 / T) * ((wCS * weight) / 100); // final grade gain per raw CS point
        buckets.push({
          weight,
          T,
          lockedS,
          editableTotal,
          editRows,
          minP,
          maxP,
          cap,
          gainPerPoint,
        });
        wsum += weight;
      });
      const csMin =
        wsum > 0
          ? buckets.reduce((acc, b) => acc + b.minP * b.weight, 0) / wsum
          : 0;
      const csMax =
        wsum > 0
          ? buckets.reduce((acc, b) => acc + b.maxP * b.weight, 0) / wsum
          : 0;

      // Helper to allocate raw points within a bucket
      function allocateRawPoints(bucket, raw) {
        const items = bucket.editRows;
        if (!items.length || raw <= 0) {
          // set scores to 0 for all editable items
          items.forEach((e) => {
            const s = e.row.querySelector(".score");
            s.value = "0";
            s.classList.add("green");
          });
          return;
        }
        const totals = items.map((it) => it.total);
        const sumTotals = totals.reduce((a, c) => a + c, 0) || 1;
        // fractional shares
        const shares = totals.map((t) => (raw * t) / sumTotals);
        const ints = shares.map((v) => Math.floor(v));
        let assigned = ints.reduce((a, c) => a + c, 0);
        let left = Math.max(0, Math.round(raw) - assigned);
        // allocate remainder to largest fractions
        const fracParts = shares.map((v, i) => ({ i, f: v - Math.floor(v) }));
        fracParts.sort((a, b) => b.f - a.f);
        for (let k = 0; k < fracParts.length && left > 0; k++) {
          ints[fracParts[k].i]++;
          left--;
        }
        // write back
        items.forEach((e, idx) => {
          let val = ints[idx];
          if (val > e.total) val = e.total;
          if (val < 0) val = 0;
          const s = e.row.querySelector(".score");
          s.value = String(val);
          s.classList.add("green");
        });
      }

      // Case 1: Exam is free (editable)
      if (!examUserLocked) {
        // baseline exam percentage at zero points (0 raw points -> 50% base-50)
        const examPercMin = map50(0, exTotal);
        // minimal final with CS at minimal and exam=0 points
        const finalMin = wCS * csMin + wExam * examPercMin + wPrev * prev;
        if (finalMin >= target - 1e-9) {
          // Achieve target with zero exam points and no CS points
          buckets.forEach((b) => allocateRawPoints(b, 0));
          examPoints = 0;
          examPerc = examPercMin;
          examInput.value = "0";
          examInput.classList.add("green");
          return recalcAll();
        }
        // Determine needed CS percent when exam=0 points
        let neededCsPercent =
          (target - (wExam * examPercMin + wPrev * prev)) / wCS;
        if (neededCsPercent <= csMin + 1e-9) {
          buckets.forEach((b) => allocateRawPoints(b, 0));
          examPoints = 0;
          examPerc = examPercMin;
          examInput.value = "0";
          examInput.classList.add("green");
          return recalcAll();
        }
        if (neededCsPercent <= csMax + 1e-9) {
          // Partial CS usage: distribute delta across buckets proportionally to weight*cap
          const delta = neededCsPercent - csMin;
          const totalCap =
            buckets.reduce((acc, b) => acc + b.weight * b.cap, 0) || 1;
          // compute raw points based on correct conversion: x_i = incHere * wsum * b.T / (50 * b.weight)
          buckets.forEach((b) => {
            if (!b.editRows.length) return;
            const share = (b.weight * b.cap) / totalCap;
            const incHere = delta * share; // weighted CS percent difference allocated to this bucket
            // convert incHere (weighted CS difference) to raw points: x_i = incHere * wsum * T / (50 * weight)
            let rawNeeded = (incHere * wsum * b.T) / (50 * b.weight);
            if (rawNeeded < 0) rawNeeded = 0;
            if (rawNeeded > b.editableTotal) rawNeeded = b.editableTotal;
            allocateRawPoints(b, rawNeeded);
          });
          examPoints = 0;
          examPerc = examPercMin;
          examInput.value = "0";
          examInput.classList.add("green");
          return recalcAll();
        }
        // Need exam points too: set CS to max then raise exam
        buckets.forEach((b) => allocateRawPoints(b, b.editableTotal));
        // compute final with exam=0 and CS=max
        const finalAt0 = wCS * csMax + wPrev * prev + wExam * examPercMin;
        let deficitExam = target - finalAt0;
        // if rounding from CS allocation already meets target, we don't need exam
        if (deficitExam <= 1e-9) {
          examPoints = 0;
          examPerc = examPercMin;
          examInput.value = "0";
          examInput.classList.add("green");
          return recalcAll();
        }
        // convert deficit (final %) to exam points: each raw exam point increases final by (50/exTotal) * wExam
        const examGainPerPoint = (50 / exTotal) * wExam;
        let needPoints = Math.ceil(deficitExam / examGainPerPoint);
        if (needPoints > exTotal) needPoints = exTotal;
        examPoints = needPoints;
        examPerc = map50(examPoints, exTotal);
        examInput.value = String(examPoints);
        examInput.classList.add("green");
        // Check impossible: if still not enough at exam=max
        const bestFinal =
          wCS * csMax + wExam * map50(exTotal, exTotal) + wPrev * prev;
        if (bestFinal + 1e-9 < target) {
          recalcAll();
          const neededExamPerc =
            (target - (wCS * csMax + wPrev * prev)) / wExam;
          $("#summary").textContent += `\n⚠️ Target is impossible.\nNeeded Exam at CS=max: ${neededExamPerc.toFixed(2)}% (>100%).`;
          return;
        }
        return recalcAll();
      }

      // Case 2: Exam is locked by user (do not modify examPoints)
      // Determine needed CS percent with exam locked
      let neededCsLocked =
        (target - (wExam * examPerc + wPrev * prev)) / wCS;
      if (neededCsLocked <= csMin + 1e-9) {
        // can drop all editables to zero
        buckets.forEach((b) => allocateRawPoints(b, 0));
        return recalcAll();
      }
      if (neededCsLocked <= csMax + 1e-9) {
        const delta = neededCsLocked - csMin;
        const totalCap =
          buckets.reduce((acc, b) => acc + b.weight * b.cap, 0) || 1;
        buckets.forEach((b) => {
          if (!b.editRows.length) return;
          const share = (b.weight * b.cap) / totalCap;
          const incHere = delta * share;
          let rawNeeded = (incHere * wsum * b.T) / (50 * b.weight);
          if (rawNeeded < 0) rawNeeded = 0;
          if (rawNeeded > b.editableTotal) rawNeeded = b.editableTotal;
          allocateRawPoints(b, rawNeeded);
        });
        return recalcAll();
      }
      // locked exam cannot reach target: show message (use CS max)
      buckets.forEach((b) => allocateRawPoints(b, b.editableTotal));
      recalcAll();
      const neededExamPercLocked =
        (target - (wCS * csMax + wPrev * prev)) / wExam;
      $("#summary").textContent += `\n⚠️ With exam locked at ${examPoints}/${exTotal} (${examPerc.toFixed(
        2
      )}%), target is impossible.\nNeeded Exam at CS=max: ${neededExamPercLocked.toFixed(
        2
      )}%.`;
    }

    // ---------- Reset only scores ----------
    function resetScores() {
      // clear exam score but leave total
      const exScore = $("#exam-score");
      exScore.value = "";
      exScore.classList.remove("green");
      // clear all score inputs
      $$("#categories .item-row .score").forEach((input) => {
        input.value = "";
        input.classList.remove("green");
      });
      // recalc but preserve totals and weights and categories
      recalcAll();
    }

    // ---------- Binding and initialization ----------
    function bindAll() {
      $("#add-category").onclick = () => {
        $("#categories").appendChild(categoryTemplate());
        recalcAll();
      };
      $("#compute").onclick = computeMinimum;
      $("#reset").onclick = () => {
        // Immediately clear all score inputs without affecting totals or weights
        resetScores();
      };
      document.body.addEventListener("input", (e) => {
        const t = e.target;
        if (t.id === "mode-prelim" || t.id === "mode-term") {
          updateModeUI();
          recalcAll();
          return;
        }
        // user typing in exam score locks it
        if (t.id === "exam-score") {
          t.classList.remove("green");
        }
        // user typing in CS score locks it
        if (t.classList?.contains("score")) {
          t.classList.remove("green");
        }
        recalcAll();
      });
      document.body.addEventListener("click", (e) => {
        const btn = e.target;
        if (btn.classList?.contains("remove")) {
          const card = btn.closest(".card");
          const item = btn.closest(".item-row");
          if (item) {
            item.remove();
            recalcAll();
            return;
          }
          if (card && card.parentElement?.id === "categories") {
            card.remove();
            recalcAll();
            return;
          }
        }
        if (btn.classList?.contains("add-item")) {
          btn
            .closest(".card")
            .querySelector(".items")
            .appendChild(itemTemplate());
          recalcAll();
          return;
        }
      });
    }
    function initFresh() {
      // default mode term
      $("#mode-term").checked = true;
      $("#mode-prelim").checked = false;
      updateModeUI();
      $("#categories").innerHTML = "";
      $("#categories").appendChild(categoryTemplate("Category 1", 50));
      $("#categories").appendChild(categoryTemplate("Category 2", 50));
      $("#exam-score").value = "";
      $("#exam-total").value = "";
      $("#prev-grade").value = "";
      $("#target-eq").value = "3.00";
      recalcAll();
    }
    window.addEventListener("load", () => {
      bindAll();
      initFresh();
    });
  </script>
</body>
</html>
